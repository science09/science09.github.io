<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-notes/wechat/distribute_id_generate">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">分布式唯一ID生成方案 | 彼岸_未来</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://science09.github.io/docs/distribute_id_generate"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="分布式唯一ID生成方案 | 彼岸_未来"><meta data-rh="true" name="description" content="分布式唯一 ID 特性"><meta data-rh="true" property="og:description" content="分布式唯一 ID 特性"><link data-rh="true" rel="icon" href="/img/favicon.png"><link data-rh="true" rel="canonical" href="https://science09.github.io/docs/distribute_id_generate"><link data-rh="true" rel="alternate" href="https://science09.github.io/docs/distribute_id_generate" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://science09.github.io/docs/distribute_id_generate" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="彼岸_未来 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="彼岸_未来 Atom Feed"><link rel="stylesheet" href="/assets/css/styles.e07c85a0.css">
<link rel="preload" href="/assets/js/runtime~main.1569ea80.js" as="script">
<link rel="preload" href="/assets/js/main.77dc109c.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Logo" class="themedImage_ToTc themedImage--light_HNdA" style="border-radius:70%"><img src="/img/logo.svg" alt="Logo" class="themedImage_ToTc themedImage--dark_i4oU" style="border-radius:70%"></div><b class="navbar__title text--truncate">彼岸_未来</b></a><a class="navbar__item navbar__link" href="/blog">个人笔记</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/notes-intro">技术文摘</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/science09" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/notes-intro">介绍</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/distribute_id_generate">公众号文章</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/distribute_id_generate">分布式唯一ID生成方案</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/how_dose_linux_filesystem_work">Linux文件系统是如何工作的？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/mysql_MVCC_and_its_implementation_principle">深入理解 MySQL 的 MVCC 及实现原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/从0.742秒到0.006秒，MySQL百万数据深分页优化实战">从0.742秒到0.006秒，MySQL百万数据深分页优化实战</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/30条永不过时的SQL优化技巧">30条永不过时的SQL优化技巧</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/21个MySQL表设计的经验准则">21个MySQL表设计的经验准则</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/MySQL的普通索引和唯一索引到底什么区别？">MySQL的普通索引和唯一索引到底什么区别？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/图文结合！Redis延迟队列golang高效实践">图文结合！Redis延迟队列golang高效实践</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="true" href="/docs/resources-webtool">资源</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/resources-webtool">工具网站列表</a></li></ul></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">公众号文章</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">分布式唯一ID生成方案</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>分布式唯一ID生成方案</h1></header><h3 class="anchor anchorWithStickyNavbar_LWe7" id="分布式唯一-id-特性"><strong>分布式唯一 ID 特性</strong><a class="hash-link" href="#分布式唯一-id-特性" title="标题的直接链接">​</a></h3><p>在业务开发中，会存在大量的场景都需要唯一 ID 来进行标识。比如，用户需要唯一身份标识；商品需要唯一标识；消息需要唯一标识；事件需要唯一标识等等。尤其是在分布式场景下，业务会更加依赖唯一 ID。</p><p>分布式唯一 ID 的特性如下：</p><ul><li><p>全局唯一：必须保证生成的 ID 是全局性唯一的，这是分布式 ID 的基本要求；</p></li><li><p>有序性：生成的 ID 需要按照某种规则有序，便于数据库的写入和排序操作；</p></li><li><p>可用性：需要保证高并发下的可用性。除了对 ID 号码自身的要求，业务还对 ID 生成系统的可用性要求极高；</p></li><li><p>自主性：分布式环境下不依赖中心认证即可自行生成 ID；</p></li><li><p>安全性：不暴露系统和业务的信息。在一些业务场景下，会需要 ID 无规则或者不规则。</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="常用分布式唯一-id-生成方案"><strong>常用分布式唯一 ID 生成方案</strong><a class="hash-link" href="#常用分布式唯一-id-生成方案" title="标题的直接链接">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="uuid"><strong>UUID</strong><a class="hash-link" href="#uuid" title="标题的直接链接">​</a></h3><p>UUID（Universally Unique Identifier，即通用唯一标识码）算法的目的是生成某种形式的全局唯一 ID 来标识系统中的任一元素，尤其是在分布式环境下，UUID 可以不依赖中心认证即可自动生成全局唯一 ID。</p><p>UUID 的标准形式为 32 个十六进制数组成的字符串，且分割为五个部分，例如：467e8542-2275-4163-95d6-7adc205580a9。</p><p>基于使用场景的不同，会存在以下几个不同版本的 UUID 以供使用，如下所示：</p><ul><li><p>基于时间的 UUID：主要依赖当前的时间戳和机器 mac 地址。优势是能基本保证全球唯一性，缺点是由于使用了 mac 地址，会暴露 mac 地址和生成时间；</p></li><li><p>分布式安全的 UUID：将基于时间的 UUID 算法中的时间戳前四位替换为 POSIX 的 UID 或 GID。优势是能保证全球唯一性，缺点是很少使用，常用库基本没有实现；</p></li><li><p>基于随机数的 UUID：基于随机数或伪随机数生成。优势是实现简单，缺点是重复几率可计算；</p></li><li><p>基于名字空间的 UUID（MD5 版）：基于指定的名字空间/名字生成 MD5 散列值得到。优势是不同名字空间/名字下的 UUID 是唯一的，缺点是 MD5 碰撞问题，只用于向后兼容；</p></li><li><p>基于名字空间的 UUID（SHA1 版）：将基于名字空间的 UUID（MD5 版）中国的散列算法修改为 SHA1。优势是不同名字空间/名字下的 UUID 是唯一的，缺点是 SHA1 计算相对耗时。</p></li></ul><p>UUID 的优势是性能非常高，由于是本地生成，没有网络消耗。而其也存在一些缺陷，包括不易于存储，UUID 太长，16 字节 128 位，通常以 36 长度的字符串表示；信息不安全，基于时间的 UUID 可能会造成机器的 mac 地址泄露；ID 作为 DB 主键时在特定的场景下会存在一些问题。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="数据库自增-id"><strong>数据库自增 ID</strong><a class="hash-link" href="#数据库自增-id" title="标题的直接链接">​</a></h3><p>数据库自增 ID 是最常见的一种生成 ID 方式。利用数据库本身来进行设置，在全数据库内保持唯一。优势是使用简单，满足基本业务需求，天然有序；缺点是强依赖 DB，会由于数据库部署的一些特性而存在单点故障、数据一致性等问题。</p><p>针对上面介绍的数据库自增 ID 的缺陷，会存在以下两种优化方案：</p><ul><li><p>数据库水平拆分，设置不同的初始值和相同的步长。这样可以有效的生成集群中的唯一 ID，也大大降低 ID 生成数据库操作的负载。</p></li><li><p>批量生成一批 ID。这样可以将数据库的压力减小到先前的 N 分之一，且数据库故障后仍可继续使用一段时间。此种方法详见下面的数据库号段模式介绍。</p></li></ul><p>数据库自增 ID 方案的优势是非常简单，可利用现有数据库系统的功能实现；ID 号单调自增。其缺陷包括强依赖 DB，当 DB 异常时整个系统将处于不可用的状态；ID 号的生成速率取决于所使用数据库的读写性能。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis-生成-id"><strong>Redis 生成 ID</strong><a class="hash-link" href="#redis-生成-id" title="标题的直接链接">​</a></h3><p>当使用数据库来生成 ID 性能不够的时候，可以尝试使用 Redis 来生成 ID。主要使用 Redis 的原子操作 INCR 和 INCRBY 来实现。优势是不依赖于数据库，使用灵活，性能也优于数据库；而缺点则是可能要引入新的组件 Redis，如果 Redis 出现单点故障问题，则会影响序号服务的可用性。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="zookeeper-生成-id"><strong>Zookeeper 生成 ID</strong><a class="hash-link" href="#zookeeper-生成-id" title="标题的直接链接">​</a></h3><p>主要是利用 Zookeeper 的 znode 数据版本来生成序列号，可以生成 32 位和 64 位的数据版本号，客户端可以使用这个版本号来作为唯一的序列号。由于需要依赖 zookeeper，并且是多步调用 API，如果在竞争较大的情况下，可能需要考虑使用分布式锁，故此种生成唯一 ID 的方法的性能在高并发的分布式环境下不甚理想。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="snowflake-算法"><strong>Snowflake 算法</strong><a class="hash-link" href="#snowflake-算法" title="标题的直接链接">​</a></h3><p>snowflake(雪花算法)是一个开源的分布式 ID 生成算法，结果是一个 long 型的 ID。snowflake 算法将 64bit 划分为多段，分开来标识机器、时间等信息，具体组成结构如下图所示：</p><p><img loading="lazy" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/e997ccdc-3e00-419d-9053-b13019a58782/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221007%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221007T144238Z&amp;X-Amz-Expires=3600&amp;X-Amz-Signature=64b1563e725fae4b893e07ee9164cd0673ee8a58291cffbd4f9c2d9ddebfd94a&amp;X-Amz-SignedHeaders=host&amp;x-id=GetObject" alt="Untitled.png" class="img_ev3q"></p><p>snowflake 算法的核心思想是使用 41bit 作为毫秒数，10bit 作为机器的 ID（比如其中 5 个 bit 可作为数据中心，5 个 bit 作为机器 ID）,12bit 作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是 0。</p><p>snowflake 算法可以根据自身业务的需求进行一定的调整。比如估算未来的数据中心个数，每个数据中心内的机器数，以及统一毫秒内的并发数来调整在算法中所需要的 bit 数。</p><p>snowflake 算法的优势是稳定性高，不依赖于数据库等第三方系统；使用灵活方便，可以根据业务需求的特性来调整算法中的 bit 位；单机上 ID 单调自增，毫秒数在高位，自增序列在低位，整个 ID 是趋势递增的。而其也存在一定的缺陷，包括强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务处于不可用状态；ID 可能不是全局递增，虽然 ID 在单机上是递增的，但是由于涉及到分布式环境下的每个机器节点上的时钟，可能会出现不是全局递增的场景。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="数据库号段模式"><strong>数据库号段模式</strong><a class="hash-link" href="#数据库号段模式" title="标题的直接链接">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="号段模式介绍"><strong>号段模式介绍</strong><a class="hash-link" href="#号段模式介绍" title="标题的直接链接">​</a></h3><p>号段模式是当下分布式 ID 生成器的主流实现方式之一，号段模式可以理解成从数据库批量获取 ID，然后将 ID 缓存在本地，以此来提高业务获取 ID 的效率。例如，每次从数据库获取 ID 时，获取一个号段，如(1,1000]，这个范围表示 1000 个 ID，业务应用在请求获取 ID 时，只需要在本地从 1 开始自增并返回，而不用每次去请求数据库，一直到本地自增到 1000 时，才去数据库重新获取新的号段，后续流程循环往复。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="美团-leaf-segment-方案"><strong>美团 Leaf-segment 方案</strong><a class="hash-link" href="#美团-leaf-segment-方案" title="标题的直接链接">​</a></h3><p>Leaf-segment 号段模式是对直接用数据库自增 ID 充当分布式 ID 的一种优化，减少对数据库的访问频率。相当于每次从数据库批量的获取自增 ID。</p><p>Leaf-server 采用了预分发的方式生成 ID，即可以在 DB 之上挂 N 个 Server，每个 Server 启动时，都会去 DB 拿固定长度的 ID List。这样就做到了完全基于分布式的架构，同时因为 ID 是由内存分发，所以也可以做到很高效。接下来是数据持久化问题，Leaf 每次去 DB 拿固定长度的 ID List，然后把最大的 ID 持久化下来，也就是并非每个 ID 都做持久化，仅仅持久化一批 ID 中最大的那一个。其流程如下图所示：</p><p><img loading="lazy" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/28c45af0-646b-4dc2-99dd-ea80b94dbc6a/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221007%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221007T144238Z&amp;X-Amz-Expires=3600&amp;X-Amz-Signature=473cc955c6b1684b5798bc4b94b228847f98a45c841a06cbfb8c2bc2b4389b9c&amp;X-Amz-SignedHeaders=host&amp;x-id=GetObject" alt="Untitled.png" class="img_ev3q"></p><p>Leaf-server 中缓存的号段耗尽之后再去数据库获取新的号段，可以大大地减轻数据库的压力。对 max_id 字段做一次 update 操作，update max_id = max_id + step，update 成功则说明新号段获取成功，新的号段范围为(max_id, max_id + step]。</p><p>为了解决从数据库获取新的号段阻塞业务获取 ID 的流程的问题，Leaf-server 中采用了异步更新的策略，同时通过双 buffer 的方式，如下图所示。通过这样一种机制可以保证无论何时 DB 出现问题，都能有一个 buffer 的号段可以正常对外提供服务，只有 DB 在一个 buffer 的下发周期内恢复，都不会影响这个 Leaf 集群的可用性。</p><p><img loading="lazy" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/2a5f6090-b79c-419e-929c-08d918543ece/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221007%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221007T144238Z&amp;X-Amz-Expires=3600&amp;X-Amz-Signature=bf9b33834a43be475edda4342a534199de5775fc25f608a278df4461f3bf7888&amp;X-Amz-SignedHeaders=host&amp;x-id=GetObject" alt="Untitled.png" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="滴滴-tingid-方案"><strong>滴滴 Tingid 方案</strong><a class="hash-link" href="#滴滴-tingid-方案" title="标题的直接链接">​</a></h3><p>Tinyid 方案是在 Leaf-segment 的算法基础上升级而来，不仅支持了数据库多主节点模式，还提供了 tinyid-client 客户端的接入方式，使用起来更加方便。</p><p>Tinyid 会将可用号段加载到内存中，并在内存中生成 ID，可用号段在首次获取 ID 时加载，如当前号段使用达到一定比例时，系统会异步的去加载下一个可用号段，以此保证内存中始终有可用号段，以便在发号服务宕机后一段时间内还有可用 ID。实现原理如下所示：</p><p><img loading="lazy" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/aaa8feb3-2ccf-4629-b014-f0c43554c8d9/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221007%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221007T144238Z&amp;X-Amz-Expires=3600&amp;X-Amz-Signature=ef497cc84f0e63f6184bfb1ad3982b46663ae71ed9b546e9692f678436d517fe&amp;X-Amz-SignedHeaders=host&amp;x-id=GetObject" alt="Untitled.png" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="微信序列号生成方案"><strong>微信序列号生成方案</strong><a class="hash-link" href="#微信序列号生成方案" title="标题的直接链接">​</a></h3><p>微信序列号跟用户 uin 绑定，具有以下性质：递增的 64 位整形；使用每个用户独立的 64 位 sequence 的体系，而不是用一个全局的 64 位（或更高位） sequence ，很大原因是全局唯一的 sequence 会有非常严重的申请互斥问题，不容易去实现一个高性能高可靠的架构。其实现方式包含如下两个关键点：</p><p>1）步进式持久化：增加一个缓存中间层，内存中缓存最近一个分配出现的 sequence：cur_seq，以及分配上限：max_seq；分配 sequence 时，将 cur_seq++，与分配上限 max_seq 比较，如果 cur_seq &gt; max_seq，将分配上限提升一个步长 max_seq += step，并持久化 max_seq；重启时，读出持久化的 max_seq，赋值给 cur_seq。此种处理方式可以降低持久化的硬盘 IO 次数，可以系统的整体吞吐量。</p><p>2）分号段共享存储：引入号段 section 的概念，uin 相邻的一段用户属于一个号段，共享一个 max_seq。该处理方式可以大幅减少 max_seq 数据的大小，同时可以进一步地降低 IO 次数。</p><p>微信序列号服务的系统架构图如下图所示：</p><p><img loading="lazy" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/74a8e15f-eef2-4c2c-b5e8-6b9992876ec8/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221007%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221007T144238Z&amp;X-Amz-Expires=3600&amp;X-Amz-Signature=5ceee35c40d26532416b87b20b2f7a03e2338c816cc9039a72af3c03bc243e59&amp;X-Amz-SignedHeaders=host&amp;x-id=GetObject" alt="Untitled.png" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="雪花模式"><strong>雪花模式</strong><a class="hash-link" href="#雪花模式" title="标题的直接链接">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="雪花模式介绍"><strong>雪花模式介绍</strong><a class="hash-link" href="#雪花模式介绍" title="标题的直接链接">​</a></h3><p>雪花模式实现方式详见上面介绍的 snowflake 算法。</p><p>由于雪花算法强依赖于机器时间，如果时间上的时钟发生回拨，则可能引起生成的 id 冲突的问题。解决该问题的方案如下所示：</p><ul><li><p>将 ID 生成交给少量服务器，然后关闭这些服务器的时钟回拨能力；</p></li><li><p>当遇到时钟回拨问题时直接报错，交给上层业务来处理；</p></li><li><p>如果回拨时间较短，在耗时要求范围内，比如 5ms，等待回拨时长后在生成 id 返回给业务侧；</p></li><li><p>如果回拨时间很长，无法等待，可以匀出少量位作为回拨位，一旦时间回拨，将回拨位加 1，可得到不一样的 ID，2 位回拨可允许标记三次时钟较长时间的回拨，基本够使用。如果超过回拨次数，可以再选择报错或抛出异常。</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="美团-leaf-snowflake-方案"><strong>美团 Leaf-snowflake 方案</strong><a class="hash-link" href="#美团-leaf-snowflake-方案" title="标题的直接链接">​</a></h3><p>Leaf-snowflake 方案沿用 snowflake 方案的 bit 位设计，即”1+41+10+12“的方式组装 ID 号（正数位（占 1 比特）+ 时间戳（占 41 比特）+ 机器 ID（占 5 比特）+ 机房 ID（占 5 比特）+ 自增值（占 12 比特）），如下图所示：</p><p><img loading="lazy" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/46fe6b63-a502-42e3-800c-2b61be5a6354/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221007%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221007T144238Z&amp;X-Amz-Expires=3600&amp;X-Amz-Signature=57cb6e53567749f262706cf3007ac377945da391c57816158ddb39cb039a35ab&amp;X-Amz-SignedHeaders=host&amp;x-id=GetObject" alt="Untitled.png" class="img_ev3q"></p><p>对于 workerID 的分配，当服务集群较小时，通过配置即可；当服务集群较大时，基于 zookeeper 持久顺序节点的特性引入 zookeeper 组件配置 workerID。部署架构如下图所示：</p><p><img loading="lazy" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/16a0f56c-0232-4e12-9c44-d9f682d4d403/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221007%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221007T144238Z&amp;X-Amz-Expires=3600&amp;X-Amz-Signature=60dc797aeef9d2257fca1675468d3f5872d8c03adbf9cb8170b9e24094ecb0d6&amp;X-Amz-SignedHeaders=host&amp;x-id=GetObject" alt="Untitled.png" class="img_ev3q"></p><p>Leaf-snowflake 方案在处理时钟回拨问题的策略如下所示：</p><p>1）服务启动时</p><ul><li><p>在服务启动时，首先检查自己是否写过 zookeeper leaf_forever 节点；</p></li><li><p>如果写过，则用自身系统时间与 leaf_forever/${self}节点记录时间做比较，若小于则认为机器时间发生了大步长回拨，服务启动失败并告警；</p></li><li><p>如果没有写过，直接创建持久节点 leaf_forever/${self}，并写入自身系统时间；</p></li><li><p>然后取 leaf_temporary 下的所有临时节点(所有运行中的 Leaf-snowflake 节点)的服务 IP：Port，然后通过 RPC 请求得到所有节点的系统时间，计算 sum(time)/nodeSize；</p></li><li><p>如果若 abs( 系统时间-sum(time)/nodeSize ) &lt; 阈值，认为当前系统时间准确，正常启动服务，同时写临时节点 leaf_temporary/${self} 维持租约；否则认为本机系统时间发生大步长偏移，启动失败并报警；</p></li><li><p>每隔一段时间(3s)上报自身系统时间写入 leaf_forever/${self}。</p></li></ul><p>2）服务运行时</p><p>会检查时钟回拨时间是否小于 5ms，若时钟回拨时间小于等于 5ms，等待时钟回拨时间后，重新产生新的 ID；若时钟回拨时间大于 5ms，直接抛异常给到业务侧。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="百度-uidgenerator-方案"><strong>百度 UidGenerator 方案</strong><a class="hash-link" href="#百度-uidgenerator-方案" title="标题的直接链接">​</a></h3><p>UidGenerator 方案是基于 snowflake 算法的唯一 ID 生成器。其对雪花算法的 bit 位的分配做了微调，如下图所示：</p><p><img loading="lazy" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/60d7e132-d2ed-4eed-b249-5f7f1ff88428/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221007%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221007T144238Z&amp;X-Amz-Expires=3600&amp;X-Amz-Signature=de13b627336e75e15c2bcd0e64ebea46d31936ed1c4fc0f55022d8fd0b2262a6&amp;X-Amz-SignedHeaders=host&amp;x-id=GetObject" alt="Untitled.png" class="img_ev3q"></p><p>UidGenerator 方案包含以下两种实现方式：</p><p>1）DefaultUidGenerator 实现方式</p><p>DefaultUidGenerator 方式的实现要点如下所示：</p><ul><li><p>delta seconds：在上图中用 28bit 部分表示，指当前时间与 epoch 时间的时间差，单位为秒。epoch 时间指集成 DefaultUidGenerator 生成分布式 ID 服务第一次上线的时间，可配置。</p></li><li><p>worker id：在上图中用 22bit 部分表示，在使用 DefaultUidGenerator 方式生成分布式 ID 的实例启动的时候，往 db 中写入一行数据得到的自增 id 值。由于 worker id 默认 22 位，允许集成 DefaultUidGenerator 生成分布式 id 的所有实例的重启次数不超过 4194303 次，否则会抛出异常</p></li><li><p>sequence：在上图中用 13bit 部分表示，通过 synchronized 保证线程安全；如果时间有任何的回拨，直接抛出异常；如果当前时间和上一次是同一秒时间，sequence 自增，如果同一秒内自增至超过 2^13-1，自旋等待下一秒；如果是新的一秒，sequence 从 0 开始。</p></li></ul><p>DefaultUidGenerator 方式在出现任何刻度的时钟回拨时都会直接抛异常给到业务层，实现比较简单粗暴。故使用 DefaultUidGenerator 方式生成分布式 ID，需要根据业务情况和特点，调整各个字段占用的位数。</p><p>2）CachedUidGenerator 实现方式</p><p>CachedUidGenerator 的核心是利用 RingBuffer，本质上是一个数组，数组中每个项被称为 slot。CachedUidGenerator 设计了两个 RingBuffer，一个保存唯一 ID，一个保存 flag。其实现要点如下所示：</p><ul><li><p>自增列：UidGenerator 的 workerId 在实例每次重启时初始化，且就是数据库的自增 ID，从而完美的实现每个实例获取到的 workerId 不会有任何冲突。</p></li><li><p>RingBuffer：UidGenerator 不再在每次取 ID 时都实时计算分布式 ID，而是利用 RingBuffer 数据结构预先生成若干个分布式 ID 并保存。</p></li><li><p>时间递增：UidGenerator 的时间类型是 AtomicLong，且通过 incrementAndGet()方法获取下一次的时间，从而脱离了对服务器时间的依赖，也就不会有时钟回拨的问题。</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="基于多时间线改进的雪花算法"><strong>基于多时间线改进的雪花算法</strong><a class="hash-link" href="#基于多时间线改进的雪花算法" title="标题的直接链接">​</a></h3><p>基于多时间线改进的雪花算法在 snowflake 基础上增加了时间线部分（1~2 位），可同时支持 2~4 条时间线并行。其对雪花算法的 bit 位的分配做了微调，如下图所示：</p><p><img loading="lazy" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/1ad51503-b479-41f4-bd34-b58d7eac0680/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&amp;X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221007%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20221007T144238Z&amp;X-Amz-Expires=3600&amp;X-Amz-Signature=9b0816eb0cd5de1f3d27464bd4e01c713210710479ed55d3cc57277d5ce972db&amp;X-Amz-SignedHeaders=host&amp;x-id=GetObject" alt="Untitled.png" class="img_ev3q"></p><p>基于多时间线改进的雪花算法生成 ID 过程如下所示：</p><ul><li><p>初始时，所有时间线进度均为基准时间，随机选定一条时间线作为当前时间线；</p></li><li><p>在当前时间线上生成 ID，同时推进当前时间线进度；</p></li><li><p>一旦发生时钟回退，且回退距离小于一定阈值，等待时间推进直到回退前的时间，会到步骤 2 继续生成 ID；</p></li><li><p>如果回退距离大于阈值，暂停当前时间线进度，选择一条合适的时间线（进度&lt;当前时间）并切换到该时间线，回到步骤 2 继续生成 ID。如果找不到合适的时间线，报错返回。</p></li></ul><p>该方案虽然通过设置时间线方式有效解决了时钟回退问题，但是削弱了 snowflake 的趋势递增特性。比较适合对于一些频繁地、小步长的时钟回退情况，即能做到全局唯一，又能很好地兼顾递增趋势。</p><p>参考资源：</p><p>【1】<a href="https://tech.meituan.com/2019/03/07/open-source-project-leaf.html" target="_blank" rel="noopener noreferrer">https://tech.meituan.com/2019/03/07/open-source-project-leaf.html</a></p><p>【2】<a href="https://cloud.tencent.com/developer/article/1598569" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1598569</a></p><p>【3】<a href="https://www.infoq.cn/article/wechat-serial-number-generator-architecture" target="_blank" rel="noopener noreferrer">https://www.infoq.cn/article/wechat-serial-number-generator-architecture</a></p><p>【4】<a href="https://juejin.cn/post/6844903686271926279#heading-1" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844903686271926279#heading-1</a></p><p>【5】<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener noreferrer">https://tech.meituan.com/2017/04/21/mt-leaf.html</a></p><p>【6】<a href="https://cloud.tencent.com/developer/article/1680001" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1680001</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/science09/science09.github.io/tree/main/docs/notes/wechat/distribute_id_generate.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"><span class="theme-last-updated">最后<!-- -->由 <b>zhaofeng.luo</b> <!-- -->更新</span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/notes-intro"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">介绍</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/how_dose_linux_filesystem_work"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">Linux文件系统是如何工作的？</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#分布式唯一-id-特性" class="table-of-contents__link toc-highlight"><strong>分布式唯一 ID 特性</strong></a></li><li><a href="#常用分布式唯一-id-生成方案" class="table-of-contents__link toc-highlight"><strong>常用分布式唯一 ID 生成方案</strong></a></li><li><a href="#uuid" class="table-of-contents__link toc-highlight"><strong>UUID</strong></a></li><li><a href="#数据库自增-id" class="table-of-contents__link toc-highlight"><strong>数据库自增 ID</strong></a></li><li><a href="#redis-生成-id" class="table-of-contents__link toc-highlight"><strong>Redis 生成 ID</strong></a></li><li><a href="#zookeeper-生成-id" class="table-of-contents__link toc-highlight"><strong>Zookeeper 生成 ID</strong></a></li><li><a href="#snowflake-算法" class="table-of-contents__link toc-highlight"><strong>Snowflake 算法</strong></a></li><li><a href="#数据库号段模式" class="table-of-contents__link toc-highlight"><strong>数据库号段模式</strong></a></li><li><a href="#号段模式介绍" class="table-of-contents__link toc-highlight"><strong>号段模式介绍</strong></a></li><li><a href="#美团-leaf-segment-方案" class="table-of-contents__link toc-highlight"><strong>美团 Leaf-segment 方案</strong></a></li><li><a href="#滴滴-tingid-方案" class="table-of-contents__link toc-highlight"><strong>滴滴 Tingid 方案</strong></a></li><li><a href="#微信序列号生成方案" class="table-of-contents__link toc-highlight"><strong>微信序列号生成方案</strong></a></li><li><a href="#雪花模式" class="table-of-contents__link toc-highlight"><strong>雪花模式</strong></a></li><li><a href="#雪花模式介绍" class="table-of-contents__link toc-highlight"><strong>雪花模式介绍</strong></a></li><li><a href="#美团-leaf-snowflake-方案" class="table-of-contents__link toc-highlight"><strong>美团 Leaf-snowflake 方案</strong></a></li><li><a href="#百度-uidgenerator-方案" class="table-of-contents__link toc-highlight"><strong>百度 UidGenerator 方案</strong></a></li><li><a href="#基于多时间线改进的雪花算法" class="table-of-contents__link toc-highlight"><strong>基于多时间线改进的雪花算法</strong></a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">本站</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">个人笔记</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/notes-intro">技术文摘</a></li></ul></div><div class="col footer__col"><div class="footer__title">我的</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/science09" target="_blank" rel="noopener noreferrer" class="footer__link-item">Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/">...</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">版权所有 © 2022  此网站使用 Docusaurus 构建。</div></div></div></footer></div>
<script src="/assets/js/runtime~main.1569ea80.js"></script>
<script src="/assets/js/main.77dc109c.js"></script>
</body>
</html>