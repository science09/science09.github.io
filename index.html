<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>彼岸-未来</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习总结 思考感悟 知识管理">
<meta property="og:type" content="website">
<meta property="og:title" content="彼岸-未来">
<meta property="og:url" content="http://science09.github.io/index.html">
<meta property="og:site_name" content="彼岸-未来">
<meta property="og:description" content="学习总结 思考感悟 知识管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="彼岸-未来">
<meta name="twitter:description" content="学习总结 思考感悟 知识管理">
  
    <link rel="alternative" href="/atom.xml" title="彼岸-未来" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://tp2.sinaimg.cn/2445097485/180/5736689505/1" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">science09</a></h1>
		</hgroup>

		
		<p class="header-subtitle">理想与现实之间的差距</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/science09" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">science09</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://tp2.sinaimg.cn/2445097485/180/5736689505/1" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">science09</h1>
			</hgroup>
			
			<p class="header-subtitle">理想与现实之间的差距</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/science09" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="9个目前流行的material-Design前端框架-md" class="article article-type-9个目前流行的material" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/08/Design前端框架-md/" class="article-date">
  	<time datetime="2015-09-08T14:06:36.000Z" itemprop="datePublished">2015-09-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/08/Design前端框架-md/">9个目前流行的Material Design前端框架</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="9个目前流行的Material_Design前端框架">9个目前流行的Material Design前端框架</h1><p>谷歌推出的Material Design风格已见有一些APP UI采用，视觉和交互体验都很棒，对于想尝试这个风格但又不懂实现一些效果的前端设计师们，可以试试今天设计达人网为大家分享的9个目前流行的Material Design前端框架。</p>
<p>这些前端框架的设计元素齐全，按钮、表单、布局及常用JS特效代码也有齐了，支持Responsive Design，还有的可以结合Bootstrap使用，相当不错，下面来看看介绍，并挑选一款你喜欢的Framework来制作你的新项目吧。</p>
<h3 id="Materialize">Materialize</h3><p>Materialize 是一个响应式的前端框架，设计样式及组件元素丰富。<br><img src="http://images.shejidaren.com/wp-content/uploads/2015/04/045516xAV.png" alt="Materialize"></p>
<p><a href="http://materializecss.com/" target="_blank" rel="external">查看框架</a></p>
<h3 id="Material_UI">Material UI</h3><p>Material UI 和上面的框架差不多，另外值得一提就是它自带的响应式日期选择很棒哦。<br><img src="http://images.shejidaren.com/wp-content/uploads/2015/04/045517J5c.png" alt="Material UI"></p>
<p><a href="http://material-ui.com/#/" target="_blank" rel="external">查看框架</a></p>
<h3 id="MUI">MUI</h3><p>MUI 是一个轻量级的Material Design框架，它的CSS和JS压缩版加起来不超过10KB，作者还提到可以用MUI的CSS来创建邮箱模板，支持流行的邮箱（如：Gmail, Apple Mail,Outlook等）</p>
<p><img src="http://images.shejidaren.com/wp-content/uploads/2015/04/045517iGV.png" alt="MUI"></p>
<p><a href="https://www.muicss.com/" target="_blank" rel="external">查看框架</a></p>
<h3 id="daemonite">daemonite</h3><p>daemonite 在之前的文章已经介绍过，轻量级。</p>
<p><img src="http://images.shejidaren.com/wp-content/uploads/2015/04/045521fAl.png" alt="daemonite"></p>
<p><a href="https://github.com/daemonite/material" target="_blank" rel="external">查看框架</a></p>
<h3 id="LumX">LumX</h3><p>LumX 这个前端框架主要是使用了Angular JS，针对手机端有不错的体验，如果懂Angular JS的建议使用这个框架。</p>
<p><img src="http://images.shejidaren.com/wp-content/uploads/2015/04/045521CdS.png" alt="LumX"></p>
<p><a href="http://ui.lumapps.com/" target="_blank" rel="external">查看框架</a></p>
<h3 id="Framaterial">Framaterial</h3><p>Framaterial 这个框架小编体验的时候，有的JS效果在桌面端感觉有点卡顿，动画不够流畅，但总体还是不错，有很丰富的组件元素。</p>
<p><img src="http://images.shejidaren.com/wp-content/uploads/2015/04/045521SBa.png" alt="Framaterial"></p>
<p><a href="http://framaterial.github.io/framaterial/" target="_blank" rel="external">查看框架</a></p>
<h3 id="Material_Framework">Material Framework</h3><p>Material Framework 这个前端框架有2组风格，一个是默认白色以及暗色调，缺点就是组件元素目前还不够多。</p>
<p><img src="http://images.shejidaren.com/wp-content/uploads/2015/04/045522mL6.png" alt="Material Framework"></p>
<p><a href="http://nt1m.github.io/material-framework/#introduction" target="_blank" rel="external">查看框架</a></p>
<h3 id="Material_Foundation">Material Foundation</h3><p>如果你懂得使用Foundation，那么这个前端框架可以选择了，直接为你的Foundation换肤。但组件还是有点少了。</p>
<p><img src="http://images.shejidaren.com/wp-content/uploads/2015/04/045522MAb.png" alt="Material Foundation"></p>
<p><a href="http://eucalyptuss.github.io/material-foundation/" target="_blank" rel="external">查看框架</a></p>
<h3 id="Material_Design_for_Bootstrap">Material Design for Bootstrap</h3><p>Material Design for Bootstrap 对于不想再去花时间了解新框架，并喜欢使用Bootstrap 的用户，那么你就用它吧。</p>
<p><img src="http://images.shejidaren.com/wp-content/uploads/2015/04/045523U4u.png" alt="Material Design for Bootstrap"></p>
<p><a href="http://fezvrasta.github.io/bootstrap-material-design/" target="_blank" rel="external">查看框架</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Android面试题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/08/Android面试题/" class="article-date">
  	<time datetime="2015-09-08T14:02:54.000Z" itemprop="datePublished">2015-09-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android面试">Android面试</h1><h3 id="1-_Android_ListView的优化">1. Android ListView的优化</h3><p> 1、使用Adapter提供的convertView<br>convertView是Adapter提供的视图缓存机制，当第一次显示数据的时候，adapter会创建n个（n等于页面可见的item的数目）convertView，当下次需要显示新的item的时候，adapter会循环利用这些已经创建的convertView，减少再次创建convertView所带来的开销，从而达到性能的提升。</p>
<p>2、使用自定义的视图缓存类<br>就是自定义一个视图缓存类，在这个类中保存我们在item中使用到的视图的引用，通过convertView的setTag方法和getTag方法来存储这个视图缓存类引用和重新获取这个视图缓存类引用，其目的也是为了减少重复创建视图时的开销。</p>
<p>3、减少不必要的视图更新<br>ListView在滚动时会请求重新获取item，来显示不同内容的item，而如果在获取item时比较耗时就会造成在滚动时出现卡顿的现象。那我们可以通过监听ListView的滚动事件来使ListView处于不同的滚动状态时做不同的事情，比如在ListView处于滚动过程中加载少量的显示数据，当ListView处于空闲的状态时再加载所有的数据，这样就可以减少ListView在滚动过程中的开销，从而提供ListView的滚动速度。</p>
<h3 id="2-_Activity的生命周期">2. Activity的生命周期</h3><p><img src="" alt=""></p>
<ol>
<li>整个的生命周期，从onCreate(Bundle)开始到onDestroy()结束。Activity在onCreate()设置所有的“全局”状态，在onDestory()释放所有的资源。例如：某个Activity有一个在后台运行的线程，用于从网络下载数据，则该Activity可以在onCreate()中创建线程,在onDestory()中停止线程。</li>
<li>可见的生命周期，从onStart()开始到onStop()结束。在这段时间，可以看到Activity在屏幕上，尽管有可能不在前台，不能和用户交互。在这两个接口之间，需要保持显示给用户的UI数据和资源等，例如：可以在onStart中注册一个IntentReceiver来监听数据变化导致UI的变动，当不再需要显示时候，可以在onStop()中注销它。onStart()，onStop()都可以被多次调用，因为Activity随时可以在可见和隐藏之间转换。</li>
<li>前台的生命周期，从onResume()开始到onPause()结束。在这段时间里，该Activity处于所有 Activity的最前面，和用户进行交互。Activity可以经常性地在resumed和paused状态之间切换，例如：当设备准备休眠时，当一个 Activity处理结果被分发时，当一个新的Intent被分发时。所以在这些接口方法中的代码应该属于非常轻量级的。</li>
</ol>
<h3 id="3-_Android的内存泄露">3. Android的内存泄露</h3><ol>
<li>查询数据库而没有关闭Cursor</li>
<li>调用registerReceiver后未调用unregisterReceiver().</li>
<li>未关闭InputStream/OutputStream</li>
<li>Bitmap使用后未调用recycle()</li>
<li>Activity中的对象的生命周期大于Activity</li>
</ol>
<h3 id="4-_Android的图片缓存原理">4. Android的图片缓存原理</h3><p>实现图片缓存也不难，需要有相应的cache策略。这里我采用 内存-文件-网络 三层cache机制，其中内存缓存包括强引用缓存和软引用缓存（SoftReference），其实网络不算cache，这里姑且也把它划到缓存的层次结构中。当根据url向网络拉取图片的时候，先从内存中找，如果内存中没有，再从缓存文件中查找，如果缓存文件中也没有，再从网络上通过http请求拉取图片。在键值对（key-value）中，这个图片缓存的key是图片url的hash值，value就是bitmap。所以，按照这个逻辑，只要一个url被下载过，其图片就被缓存起来了。</p>
<p>关于Java中对象的软引用（SoftReference），如果一个对象具有软引用，内存空间足够，垃 圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高 速缓存。使用软引用能防止内存泄露，增强程序的健壮性。</p>
<p>从代码上来说，采用一个ImageManager来负责图片的管理和缓存，函数接口为public void loadBitmap(String url, Handler handler) ；其中url为要下载的图片地址，handler为图片下载成功后的回调，在handler中处理message，而message中包含了图片的信息以及bitmap对象。</p>
<h3 id="5-_如何处理Android多分辨率适配问题">5. 如何处理Android多分辨率适配问题</h3><p> UI界面在不同平台的适配受屏幕尺寸和屏幕密度影响，Android适配机制就是在资源后面添加对这两种因素的限定，通过不同的限定区分不同的平台资源，Android在使用资源的时候会优先选择满足本平台限定的资源，再找最接近条件的，再找默认（即不加限定），通过选择适合当前平台的资源来完成不同平台的适配。</p>
<h3 id="6-_什么是ANR，如何防止">6. 什么是ANR，如何防止</h3><p>在Android上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称作应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择让程序继续运行，但是，他们在使用你的应用程序时，并不希望每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样，系统不会显示ANR给用户。</p>
<p>任何运行在主线程中的方法，都要尽可能的只做少量的工作。特别是活动生命周期中的重要方法如onCreate()和 onResume()等更应如此。潜在的比较耗时的操作，如访问网络和数据库;或者是开销很大的计算，比如改变位图的大小，需要在一个单独的子线程中完成(或者是使用异步请求，如数据库操作)。但这并不意味着你的主线程需要进入阻塞状态已等待子线程结束 – 也不需要调用Therad.wait()或者Thread.sleep()方法。取而代之的是，主线程为子线程提供一个句柄(Handler)，让子线程在即将结束的时候调用它(xing:可以参看Snake的例子，这种方法与以前我们所接触的有所不同)。使用这种方法涉及你的应用程序，能够保证你的程序对输入保持良好的响应，从而避免因为输入事件超过5秒钟不被处理而产生的ANR。</p>
<h3 id="7-_JNI调用过程">7. JNI调用过程</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Android解析XML格式数据" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/08/Android解析XML格式数据/" class="article-date">
  	<time datetime="2015-09-08T14:02:54.000Z" itemprop="datePublished">2015-09-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android解析XML格式数据">Android解析XML格式数据</h1><p>XML在各种开发中都广泛应用，Android也不例外。作为承载数据的一个重要角色，如何读写XML成为Android开发中一项重要的技能。今天就由我向大家介绍一下在Android平台下几种常见的XML解析和创建的方法。</p>
<p>在Android中，常见的XML解析器分别为SAX解析器、DOM解析器和PULL解析器，下面，我将一一向大家详细介绍。</p>
<h3 id="SAX解析器：">SAX解析器：</h3><p>SAX(Simple API for XML)解析器是一种基于事件的解析器，它的核心是事件处理模式，主要是围绕着事件源以及事件处理器来工作的。当事件源产生事件后，调用事件处理器相应的处理方法，一个事件就可以得到处理。在事件源调用事件处理器中特定方法的时候，还要传递给事件处理器相应事件的状态信息，这样事件处理器才能够根据提供的事件信息来决定自己的行为。</p>
<p>SAX解析器的优点是解析速度快，占用内存少。非常适合在Android移动设备中使用。</p>
<h3 id="DOM解析器：">DOM解析器：</h3><p>DOM是基于树形结构的的节点或信息片段的集合，允许开发人员使用DOM API遍历XML树、检索所需数据。分析该结构通常需要加载整个文档和构造树形结构，然后才可以检索和更新节点信息。</p>
<p>由于DOM在内存中以树形结构存放，因此检索和更新效率会更高。但是对于特别大的文档，解析和加载整个文档将会很耗资源。</p>
<h3 id="PULL解析器：">PULL解析器：</h3><p>PULL解析器的运行方式和SAX类似，都是基于事件的模式。不同的是，在PULL解析过程中，我们需要自己获取产生的事件然后做相应的操作，而不像SAX那样由处理器触发一种事件的方法，执行我们的代码。PULL解析器小巧轻便，解析速度快，简单易用，非常适合在Android移动设备中使用，Android系统内部在解析各种XML时也是用PULL解析器。</p>
<p>以上三种解析器，都是非常实用的解析器，我将会一一介绍。我们将会使用这三种解析技术完成一项共同的任务。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Android 常用工具类库" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/08/Android 常用工具类库/" class="article-date">
  	<time datetime="2015-09-08T14:02:54.000Z" itemprop="datePublished">2015-09-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android_常用工具类库">Android 常用工具类库</h1><p>在Android开发中，经常用到的一些功能：</p>
<ol>
<li>下载，比如图片，文件。</li>
<li>将下载的文件进行解压。</li>
<li>请求服务器，比如说上传登陆信息，更新某些数据，又或者上传头像文件。</li>
<li>从文件系统中选择要操作的文件（图片，拍照，视频，拍摄视频）。</li>
<li>有时候也需要爬取某些网页数据。</li>
<li>存储一些配置信息</li>
<li>播放视频</li>
<li>再有一个特殊需求就是关乎Android程序UI设计，图标是个很麻烦的问题。每次都难以找到合适的Android 设计UI。</li>
</ol>
<h2 id="Android开发库Afinal">Android开发库Afinal</h2><p>afinal是一个很方便的工具库。<br><a href="https://github.com/yangfuhai/afinal" target="_blank" rel="external">GitHub</a><br><a href="http://www.zimeitix.com/" target="_blank" rel="external">作者博客</a> （注：国人项目哟）</p>
<ul>
<li>一行代码就可以对数据库进行增删改查。 </li>
<li>完全注解方式就可以进行UI绑定和事件绑定。无需findViewById和setClickListener等。</li>
<li>轻松实现Android上传文件，POST数据，下载文件（支持断点续传，随时停止下载任务 或者 开始任务）。</li>
<li>一行代码加载网络图片。</li>
</ul>
<h2 id="android-async-http">android-async-http</h2><p>Android下的异步HTTP库。<br><a href="https://github.com/loopj/android-async-http" target="_blank" rel="external">GitHub</a><br><a href="http://loopj.com/android-async-http/" target="_blank" rel="external">文档</a>    PS：作者的GitHub值得关注。</p>
<ul>
<li>发送异步http请求，并且可在回调函数中处理返回响应Response。</li>
<li>http请求在thread线程，不会阻塞UI线程。</li>
<li>请求使用线程池（ThreadPool）实现，优化了并发的资源使用。</li>
<li>支持Multipart 文件上传。</li>
<li>如果Request请求失败，会自动请求。</li>
<li>支持Json解码。</li>
<li>支持存储Cookies到Preference中。</li>
<li>支持gzip处理Request以及Response。</li>
<li>整个库只有19KB。</li>
</ul>
<h2 id="http-requests">http-requests</h2><p>Java http请求库，设计的很优雅的一个库，推荐。<br><a href="https://github.com/kevinsawicki/http-request" target="_blank" rel="external">GitHub</a></p>
<h2 id="async-http-client">async-http-client</h2><p>Android下的异步 Http 和 WebSocket 库。<br><a href="https://github.com/AsyncHttpClient/async-http-client" target="_blank" rel="external">GitHub</a></p>
<ul>
<li>支持代理设置</li>
<li>支持分片儿处理请求返回内容</li>
<li>支持WebSocket</li>
</ul>
<h2 id="zt-zip:">zt-zip:</h2><p>压缩和解压库的库。<br><a href="https://github.com/zeroturnaround/zt-zip" target="_blank" rel="external">GitHub</a></p>
<ul>
<li>压缩和解压</li>
<li>单独操作文件压缩和解压。</li>
<li>替换zip文件中的某个文件</li>
</ul>
<h2 id="aFileChooser">aFileChooser</h2><p>文件选择器,用于选择需要操作的文件<br><a href="https://github.com/iPaulPro/aFileChooser" target="_blank" rel="external">GitHub</a></p>
<h2 id="image-chooser-library">image-chooser-library</h2><p>图片和视频的选择库。<br><a href="https://github.com/coomar2841/image-chooser-library" target="_blank" rel="external">GitHub</a><br><a href="https://play.google.com/store/apps/details?id=com.beanie.imagechooserapp" target="_blank" rel="external">Demo</a></p>
<h2 id="jsoup">jsoup</h2><p>HTML解析，并且能很好理解DOM，CSS，以及JQuery。<br><a href="https://github.com/jhy/jsoup" target="_blank" rel="external">GitHub</a><br><a href="http://jsoup.org/" target="_blank" rel="external">官方</a>   PS：这是java库。做网页爬虫（Crawler,Robot）必备。</p>
<h2 id="toml">toml</h2><p>这是个跨语言的配置信息存取方案。<br><a href="https://github.com/mojombo/toml" target="_blank" rel="external">GitHub</a></p>
<h2 id="Androiton-Action-Bar-Icons">Androiton-Action-Bar-Icons</h2><p>一个针对Android 优化过的ICON图标集。<br><a href="https://github.com/svenkapudija/Androton-Action-Bar-Icons" target="_blank" rel="external">GitHub</a><br><a href="https://a248.e.akamai.net/camo.github.com/13191b852f282fa929aad94cccc4d885c77e5d2a/687474703a2f2f692e696d6775722e636f6d2f576b654e496b522e706e67" target="_blank" rel="external">Demo</a></p>
<h2 id="ThinkAndroid">ThinkAndroid</h2><p>推荐一个Android整体框架：ThinkAndroid 集成了ioc，orm，下载，缓存等模块，能让开发更加快速和高效，同时还是国人项目。<br><a href="https://github.com/white-cat/ThinkAndroid" target="_blank" rel="external">GitHub</a></p>
<h2 id="OKHTTP">OKHTTP</h2><p>如果你想要更快的网络传输和加载速度可以试试OKHTTP，他实现了Google开发的SPDY协议，通过复用一个Socket，缩短网络加载时间。<br><a href="http://www.williamlong.info/archives/3119.html" target="_blank" rel="external">关于SPDY看这里</a><br><a href="http://square.github.io/okhttp/" target="_blank" rel="external">OKHTTP</a></p>
<h2 id="Android-ProgressFragment">Android-ProgressFragment</h2><p>等待数据的时候，支持显示等待符号的Fragment控件。<br><a href="https://github.com/johnkil/Android-ProgressFragment" target="_blank" rel="external">GitHub</a></p>
<h2 id="Vitamio">Vitamio</h2><p>关于播放视频，不要再去研究什么FFMPEG了，too slow，国人有个非常非常出色的开源项目叫Vitamio，让你播放视频简单如abc。<br><a href="https://github.com/yixia/VitamioBundle" target="_blank" rel="external">GitHub</a><br><a href="http://www.vitamio.org/" target="_blank" rel="external">官方网站</a></p>
<h2 id="AndroidCommon">AndroidCommon</h2><p>Android常用的一些库和功能，如缓存，下拉列表，下载管理，静默安装等。感谢Trinea  <a href="https://github.com/Trinea/AndroidCommon" target="_blank" rel="external">GitHub</a></p>
<h2 id="ion">ion</h2><p>让Android的网络操作变得极其简单，支持异步获取和处理JSON，支持Android文件下载（同时支持下载进度条绑定），支持安全链接和代理。超级推荐！<br><a href="https://github.com/koush/ion" target="_blank" rel="external">GitHub</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Android apk 反编译" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/08/Android apk 反编译/" class="article-date">
  	<time datetime="2015-09-08T14:02:54.000Z" itemprop="datePublished">2015-09-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android_apk反编译">Android apk反编译</h1><p>一、Apk反编译得到Java源代码</p>
<p>下载上述反编译工具包，打开apk2java目录下的dex2jar-0.0.9.9文件夹，内含apk反编译成java源码工具，以及源码查看工具。</p>
<p>apk反编译工具dex2jar，是将apk中的classes.dex转化成jar文件</p>
<p>源码查看工具jdgui，是一个反编译工具，可以直接查看反编译后的jar包源代码</p>
<p>dex2jar 和 jdgui 最新版本下载，分别见google code：</p>
<p>dex2jar（google code）</p>
<p>jdgui（google code），最新版本请见 官方</p>
<h3 id="具体步骤：">具体步骤：</h3><p>首先将apk文件后缀改为zip并解压，得到其中的classes.dex，它就是java文件编译再通过dx工具打包而成的，将classes.dex复制到dex2jar.bat所在目录dex2jar-0.0.9.9文件夹。</p>
<p>在命令行下定位到dex2jar.bat所在目录，运行</p>
<p>dex2jar.bat    classes.dex</p>
<p>生成</p>
<p>classes_dex2jar.jar</p>
<h3 id="一、工具准备：apktool_,_dex2jar_,_jd-gui">一、工具准备：apktool , dex2jar , jd-gui</h3><h3 id="二、使用dex2jar_+_jd-gui_得到apk的java源码">二、使用dex2jar + jd-gui 得到apk的java源码</h3><ol>
<li>用解压工具从 apk包中取出 classes.dex 文件<br>用命令(dex2jar.bat classes.dex)得到一个 jar文件</li>
<li>用jd-gui反编译工具将得到.jar文件反编译成.java文件</li>
</ol>
<h3 id="三、使用apktool得到apk的xml文件">三、使用apktool得到apk的xml文件</h3><ol>
<li>用命令(apktool d xxx.apk xxx_xml)反编译xxx.apk包</li>
<li>从 xxx_xml 文件夹得到xml文件</li>
</ol>
<h3 id="四、第二步_得到的程序源代码_和_第三步_得到的xml文件组合下，即可得到完整的apk源码。">四、第二步 得到的程序源代码 和 第三步 得到的xml文件组合下，即可得到完整的apk源码。</h3><h3 id="五、应用：_汉化/去广告，加_values-zh-rCN,_values-zh-rTW,_values-de,_values-fr">五、应用： 汉化/去广告，加 values-zh-rCN, values-zh-rTW, values-de, values-fr</h3><ol>
<li>在步骤三的文件夹xxx_xml/res/ 下， 建文件夹: values-zh-rCN,values-zh-rTW</li>
<li>复制values\strings.xml 到   values-zh-rCN 并翻译.</li>
<li>去广告见；</li>
<li>重建APK,用命令(apktool b xxx) ，输出到ABC/dist/out.apk<br>或命令( apktool b xxx out.apk)</li>
</ol>
<h3 id="六、重新打包_和_签名">六、重新打包 和 签名</h3><p>1) 汉化apk应用程序</p>
<pre><code>汉化apk就是 把 反编译之后apk 下的<span class="keyword">res</span>/<span class="built_in">values</span>文件夹内<span class="built_in">string</span>.xml文件的内容 汉化（注意：我们的例子里 只有一个<span class="built_in">string</span>.xml，有时候 可能 不止 一个 *xml 文件，那么 我们 需要把 相应的 位置 都汉化）。

 一个apk应用在汉化后应该能在英文和中文系统下都能使用。/<span class="built_in">values</span>目录下的是英文语言包。为了建一个中文语言包，与/<span class="built_in">values</span>并行创建一个子文件夹：/<span class="built_in">values</span>-zh-rCN（必须用这个文件名！）。这里<span class="built_in">values</span>-zh是中国地区语言包（包含港澳台及内地），<span class="built_in">values</span>-zh-rCN是中文简体语言包（只包含内地），<span class="built_in">values</span>-zh-rTW是中文繁体语言包（港澳台）。
</code></pre><p>把/values文件夹里的strings.xml等语言文件复制进/values-zh-rCN。在我们的例子中，只有strings.xml一个文件。<br>进入/values-zh-rCN，用文本编辑器打开strings.xml，然后你就翻译吧，把英文描述译成相应的中文。</p>
<p>高级内容：以上的汉化是修改string.xml，把英文译成相应的中文就好了，然后打包和签名。但是，在有些apk文件里，所显示的字符文字并不都在xml文件里。apk原作者把某些字符写在代码中。反编译后，存放在/smali文件夹里。一层一层地找下去，最后你会看到一大堆Dalvik码文件，都是以.smali为文件扩展名。举一个例子，用文本编辑器打开某个.smali文件，看到:<br>const-string v5, “ServiceMode”<br>“ServiceMode”会在apk执行时显示为英文。因此，需要汉化。在I897 ROM里，用工程模式特殊代码看到的多半属于这一类。汉译起来非常花时间。我们要把ServiceMode译成“服务模式”。怎么处理呢？你不能把const-string v5, “ServiceMode”直接改成const-string v5, “服务模式”。打包会失败的。正确的做法是把相应的中文字符用16进制的unicode来表示。例如：把“服务模式”用16进制的unicode表示就是\u670d\u52a1\u6a21\u5f0f 。每一个汉字用4个字符表示，\u表示为16进制的unicode码。好了，正确的汉译是：<br>const-string v5, “\u670d\u52a1\u6a21\u5f0f “<br>网上有中文字符与16进制unicode码的对照表或转换工具。</p>
<p>2) 修改图标标签</p>
<p>每一个apk文件都有一个“图标标签”。将apk程序安装进手机后，在图标下面显示图标标签文字。这个图标标签的内容是可以修改的。在\res\values下找到strings.xml，修改其中的一行：</p>
<p><string name="app_name">图标标签</string><br>例如：<string name="app_name">静音启动</string><br>同理，如果是窗口小插件，要修改widget_name。</p>
<p>3) 去掉apk中的广告</p>
<p>有很多apk应用都带有广告。为了去掉程序中的广告，要修改main.xml文件与广告有关的内容。在/res目录下找到文件main.xml。通常在/layout目录下，有时也被放在其它目录下。甚至，有时不存在main.xml文件，广告行被放在其它xml文件内。只能细心逐个文件进行查找。无论哪一种情况，查看其内容，你会看到有一项类似的命令如下。这就是广告显示。</p>
<p><com.admob.android.ads.adview android:id="”@id/ad”" android:layout_width="”fill_parent”" android:layout_height="”wrap_content”" admobsdk:backgroundcolor="”#ff000000″" admobsdk:textcolor="”#ffffffff”" admobsdk:keywords="”Android" application”=""><br>将其改为：</com.admob.android.ads.adview></p>
<p><com.admob.android.ads.adview android:id="”@id/ad”" android:layout_width="”0.0dip”" android:layout_height="”0.0dip”" admobsdk:backgroundcolor="”#ff000000″" admobsdk:textcolor="”#ffffffff”" admobsdk:keywords="”Android" application”=""><br>可以看到，关键是要把fill_parent改为0.0dip，把wrap_content改为0.0dip，其它内容保持不变即可。这种改法就是不给广告显示空间，当然你就看不到广告了。</com.admob.android.ads.adview></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Android WebView内存泄漏" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/08/Android WebView内存泄漏/" class="article-date">
  	<time datetime="2015-09-08T14:02:54.000Z" itemprop="datePublished">2015-09-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android_WebView内存泄漏">Android WebView内存泄漏</h1><p>在这次开发过程中，需要用到webview展示一些界面，但是加载的页面如果有很多图片就会发现内存占用暴涨，并且在退出该界面后，即使在包含该 webview的Activity的destroy()方法中，使用webview.destroy();webview=null;对内存占回收用还是没有任何效果。有人说，一旦在你的xml布局中引用了webview甚至没有使用过，都会阻碍重新进入Application之后对内存的gc。包括使用 MapView有时一会引发OOM，几经周折在网上看到各种解决办法，在这里跟大家分享一下。但是到目前为止还没有找到根本的解决办法，网上也有说是 sdk的bug。但是不管怎么样，我们还是需要使用的。</p>
<p>要使用WebView不造成内存泄漏，首先应该做的就是不能在xml中定义webview节点，而是在需要的时候动态生成。即：可以在使用WebView 的地方放置一个LinearLayout类似ViewGroup的节点，然后在要使用WebView的时候，动态生成即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebView      mWebView = <span class="keyword">new</span> WebView(getApplicationgContext()); </span><br><span class="line">LinearLayout mll      = findViewById(R.id.xxx); </span><br><span class="line">mll.addView(mWebView);</span><br></pre></td></tr></table></figure>
<p>然后一定要在onDestroy()方法中显式的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onDestroy();</span><br><span class="line">      mWebView.removeAllViews();</span><br><span class="line">      mWebView.destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意： new  WebView(getApplicationgContext()) ;必须传入ApplicationContext如果传入Activity的 Context的话，对内存的引用会一直被保持着。有人用这个方法解决了当Activity被消除后依然保持引用的问题。但是你会发现，如果你需要在 WebView中打开链接或者你打开的页面带有flash，获得你的WebView想弹出一个dialog，都会导致从 ApplicationContext到ActivityContext的强制类型转换错误，从而导致你应用崩溃。这是因为在加载flash的时候，系统 会首先把你的WebView作为父控件，然后在该控件上绘制flash，他想找一个Activity的Context来绘制他，但是你传入的是 ApplicationContext。后果，你可以晓得了哈。</p>
<p>于是大牛们就Activity销毁后还保持引用这个问题，提供了另一种解决办法：既然你不能给我删除引用，那么我就自己来吧。于是下面的这种方法诞生了：</p>
<p>（作者说这个方法是依赖android.webkit implementation有可能在最近的版本中失败）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigCallback</span><span class="params">(WindowManager windowManager)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field field = WebView.class.getDeclaredField(<span class="string">"mWebViewCore"</span>); </span><br><span class="line">        field = field.getType().getDeclaredField(<span class="string">"mBrowserFrame"</span>); </span><br><span class="line">        field = field.getType().getDeclaredField(<span class="string">"sConfigCallback"</span>); </span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>); </span><br><span class="line">        Object configCallback = field.get(<span class="keyword">null</span>); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == configCallback) &#123; </span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        field = field.getType().getDeclaredField(<span class="string">"mWindowManager"</span>); </span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>); </span><br><span class="line">        field.set(configCallback, windowManager); </span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在Activity中调用上面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState); </span><br><span class="line">    setConfigCallback((WindowManager)getApplicationContext().getSystemService(Context.WINDOW_SERVICE)); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setConfigCallback(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">super</span>.onDestroy(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该反射方法在我的实验中（2.3.6）确实有些用处，在应用内存占用到70M左右的时候会明显释放到50M或者60M然后的释放就有些缓慢，其实就是看不出来了。之前在没使用该方法的时候可能达到120M。</p>
<p>但是！！！我们的应用要求占用内存更低啊，这肿么拌？凉拌么？No。在各种纠结之后，终于找到了终极解决办法！！！该办法适用于我们的需求，在退出 WebView的界面之后，迅速回收内存。要问这个方法是什么，不要9999，不要8999，只要你仔细看好下面一句话：那就是为加载WebView的界 面开启新进程，在该页面退出之后关闭这个进程。</p>
<p>这一点说了之后，你懂了吧？<br>但是在这个其中，杀死自己进程的时候又遇到了问题，网上介绍的各种方法都不好使，<br>killBackgroundProcesses(getPackageName());各种不好用，最后使用System.exit(0);直接退出虚拟机（Android为每一个进程创建一个虚拟机的）。这个肯定不用纠结了，一旦退出，内存里面释放。听涛哥说QQ也是这么做。</p>
<p>最后英雄要问出处，附上大牛解说引起该问题的出处</p>
<p>这个泄漏出现在external/webkit/Source/WebKit/android/WebCoreSupport/UrlInterceptResponse.cpp.中。具体我自己真心没有深入研究。大家有兴趣的话，可以看看哈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--- a/Source/WebKit/android/WebCoreSupport/UrlInterceptResponse.cpp </span><br><span class="line">+++ b/Source/WebKit/android/WebCoreSupport/UrlInterceptResponse.cpp </span><br><span class="line">@@ -<span class="number">63</span>,<span class="number">10</span> +<span class="number">63</span>,<span class="number">10</span> @@ <span class="keyword">public</span>: </span><br><span class="line">         JNIEnv* env = JSC::Bindings::getJNIEnv(); </span><br><span class="line">         <span class="comment">// Initialize our read buffer to the capacity of out. </span></span><br><span class="line">         <span class="keyword">if</span> (!m_buffer) &#123; </span><br><span class="line">-            m_buffer = env-&gt;NewByteArray(out-&gt;capacity()); </span><br><span class="line">-            m_buffer = (jbyteArray) env-&gt;NewGlobalRef(m_buffer); </span><br><span class="line">+            <span class="function">ScopedLocalRef&lt;jbyteArray&gt; <span class="title">buffer_local</span><span class="params">(env, env-&gt;NewByteArray(out-&gt;capacity()</span>))</span>; </span><br><span class="line">+            m_buffer = static_cast&lt;jbyteArray&gt;(env-&gt;NewGlobalRef(buffer_local.get())); </span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">int</span> size = (<span class="keyword">int</span>) env-&gt;CallIntMethod(m_inputStream, m_read, m_buffer); </span><br><span class="line">         <span class="keyword">if</span> (checkException(env) || size &lt; <span class="number">0</span>) </span><br><span class="line">             <span class="keyword">return</span>; </span><br><span class="line">         <span class="comment">// Copy from m_buffer to out.</span></span><br></pre></td></tr></table></figure>
<p>而且从这里了解 <a href="https://github.com/android/platform_external_webkit/commit/1e3e46a731730c02d916ea805ec4b20191509282" target="_blank" rel="external">这个bug的解决状态</a> 。</p>
<p>还有一个问题要说的，也是在WebView使用的时候出现的问题：WebView 中包含一个ZoomButtonsController，当使用 web.getSettings().setBuiltInZoomControls(true);启用该设置后，用户一旦触摸屏幕，就会出现缩放控制图 标。这个图标过上几秒会自动消失，但在3.0系统以上上，如果图标自动消失前退出当前Activity的话，就会发生ZoomButton找不到依附的 Window而造成程序崩溃，解决办法很简单就是在Activity的ondestory方法中调用 web.setVisibility(View.GONE);方法，手动将其隐藏，就不会崩溃了。在3.0一下系统上不会出现该崩溃问题，真是各种崩溃， 防不胜防啊！</p>
<p>最后还有内存泄漏的一些个建议：</p>
<p>In summary, to avoid context-related memory leaks, remember the following:</p>
<ul>
<li>Do not keep long-lived references to a context-activity (a reference to an activity should have the same life cycle as the activity itself)</li>
<li>Try using the context-application instead of a context-activity</li>
<li>Avoid non-static inner classes in an activity if you don’t control their life cycle, use a static inner class and make a weak reference to the activity inside</li>
<li>And remember that a garbage collector is not an insurance against memory leaks. Last but not least, we try to make such leaks harder to make happen whenever we can.</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Android App 性能优化实践" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/08/Android App 性能优化实践/" class="article-date">
  	<time datetime="2015-09-08T14:02:54.000Z" itemprop="datePublished">2015-09-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android_App_性能优化实践">Android App 性能优化实践</h1><h2 id="工具">工具</h2><p>Hierarchy Viewer 是 Android SDK 自带的 Layout 嵌套检查工具，以可视化的布局角度直观获取 Layout 布局设计和各种属性信息，来帮助我们完成优化布局的设计。需要注意的是，出于安全考虑 Hierarchy Viewer 只能连接Android开发版手机(需要安装ViewServer)或是模拟器。</p>
<p><img src="D:\Study_Material\建站资料\博客文章\PicResource\performance-tuning-on-android-1.png" alt=""></p>
<p>注意上图右半部分显示的时间</p>
<ul>
<li>Measure： 0.977ms</li>
<li>Layout： 0.167ms</li>
<li>Draw： 2.717ms</li>
</ul>
<p>我们知道Android View在绘制图形的时候主要耗时的操作就在 Measure、Layout 和 Draw 这三个过程；并且任何一个 View 绘制时间不能超过 16.7ms(每秒60帧才能保证流畅度)。</p>
<p>如果 UI 出现卡顿或掉帧，那么 Hierarchy Viewer 这个工具及其有用，可以分析当前 View 是哪些 View 以及是 View 的哪个过程加载延迟，通过这些信息基本可定位到局部 Code。</p>
<h4 id="如何让QC快速追踪和定位性能问题？">如何让QC快速追踪和定位性能问题？</h4><p>当然使用 Android 开发者工具里的 <a href="http://developer.android.com/about/versions/jelly-bean.html" target="_blank" rel="external">Profile GPU rendering (GPU呈现模式分析)</a> 工具(Android4.1以上)。它能够从屏幕上活动的所有Android Activity生成性能视图，其中绿线代表 16ms，频繁超过此线的 Activity 就要排查性能问题了。</p>
<h4 id="如何定位到某个方法？">如何定位到某个方法？</h4><p>用 Hierarchy Viewer 知道是哪一个子 View 耗时比较多，找到此 View 的Code，那么如何定位到具体某个方法里呢？ 当然需要 <a href="http://developer.android.com/tools/debugging/debugging-tracing.html" target="_blank" rel="external">traceview</a> 工具。traceview 工具十分强大，可以轻松把每个方法占用 CPU 时间计算出来，找到占用时间最长的方法，然后分析此方法即可。</p>
<p>Lint 工具已经集成于 Android Studio，同样是非常强大的工具。它会给出 Layout 优化提示(既包括图片资源、layout文件，也有定义的String常量和Color常量以及Layout写法不规范)，告诉你哪些资源没有被引用，Manifest文件的错误等；我主要用 lint 来哪些资源文件没有被引用到(给APK瘦身)，以及部分代码不规范的地方。</p>
<h4 id="内存优化工具">内存优化工具</h4><p>Memory Monitor：查看整个app所占用的内存，以及发生GC的时刻，短时间内发生大量的GC操作是一个危险的信号(发生内存抖动)。</p>
<p>Allocation Tracker：追踪内存的分配。</p>
<p>Heap Tool：查看当前内存快照，便于对比分析哪些对象有可能是泄漏了的。</p>
<h2 id="布局优化">布局优化</h2><h4 id="布局标签">布局标签</h4><p><include> 标签，将布局中公共部分提取出来共用；例如网易新闻一条新闻的标题栏和评论界面的标题栏。</include></p>
<p><viewstub> 标签，同 include，可引入布局，但是默认情况引入的布局不会占用资源，在解析当前 Layout 时节省计算、内存资源。当需要加载此 View 的时候，需要动态 inflate 起来。</viewstub></p>
<blockquote>
<p> Tips：将一个view设置为GONE不会被系统解析，从而提高layout解析速度，而VISIBLE和INVISIBLE这两个可见性属性会被正常解析。</p>
</blockquote>
<p><merge> 标签，解决 Layout 嵌套过多的问题，通过工具通过 hierarchy viewer 可直观的显示出来。</merge></p>
<h4 id="其他">其他</h4><p>减少 inflate 次数：inflate 是比较耗资源的，当内存够用时，可以将 View 缓存起来，下次直接使用；用空间换时间。</p>
<h2 id="代码Tips">代码Tips</h2><p><a href="http://www.trinea.cn/android/java-android-performance/" target="_blank" rel="external">性能优化之Java(Android)代码优化</a>，这篇博客详细介绍了如何进行代码优化，包括缓存、数据存储、异步、数据库和网络等操作的优化。</p>
<p>关于缓存，上文没有提到一个重要的库：DiskLruCache；DiskLruCache 是关于数据硬盘缓存的，<a href="http://blog.csdn.net/guolin_blog/article/details/28863651" target="_blank" rel="external">Android DiskLruCache</a>完全解析，硬盘缓存的最佳方案 这篇博客详细介绍了 DiskLruCache 使用方法和注意事项。</p>
<p><strong>避免随意使用静态变量</strong>，当某个对象被定义为stataic变量所引用，虚拟机通常是不会回收这个对象所占有的内存。</p>
<p>避免过多过常的创建java对象，JVM 创建和回收耗时，频繁使用对象，最好创建缓存；每次回收对象，都是 STW(Stop the World)，所以如果对象过多，可能引起卡顿(大于16ms，引起掉帧)。可用 Memory Monitor 或 Allocation Tracker 工具来查看这类问题。</p>
<p><strong>多使用局部变量</strong>，函数执行完，就释放内存被虚拟机回收。</p>
<p><strong>使用StringBuilder和StringBuffer进行字符串连接</strong>，尤其在做 SQL 拼装的时候。</p>
<p><strong>单线程应尽量使用HashMap, ArrayList</strong>，如果不确定是单线程还是多线程，建议还是用 ConcurrentHashMap…</p>
<p><strong>尽量在finally块中释放资源</strong>，例如很多 Cursor。</p>
<p><strong>慎用异常</strong>，创建一个异常时，需收集一个栈记录(stack track)，用于描述异常是在何处创建的。构建这些此栈时需要为运行时栈做一份快照，这一部分开销很大。</p>
<h2 id="View绘制">View绘制</h2><h4 id="过度绘制问题">过度绘制问题</h4><p>为什么会出现过度绘制：多个 View 重叠，复杂 Layout 叠加；导致 GPU 需要绘制多层，有些时候非常耗时。</p>
<p><a href="http://www.androidperformance.com/android-performance-optimization-overdraw-1.html" target="_blank" rel="external">Android性能优化之过渡绘制</a>，这篇博客作者用实例来解决过度绘制的问题，解决过度绘制问题时，作者也使用了我们上面介绍的几个工具。</p>
<h4 id="View局部更新">View局部更新</h4><p>一些复杂的 View，如果每次 View 有局部更新都要重新绘制 View的话，GPU 会显得力不从心。通过canvas.clipRect() 方法来让系统识别可绘制区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。clipRect方法节约了CPU与GPU资源，不会绘制clipRect区域外的地方，仅仅绘制内容在矩形区域内的组件。</p>
<h2 id="电量优化">电量优化</h2><p>尽量减少唤醒屏幕的次数与持续的时间(屏幕是用电大户)，用WakeLock来处理唤醒的问题，能够正确执行唤醒操作并根据设定及时关闭操作进入睡眠状态，使用 wakelock.acquice() 方法，一定要加上超时处理(例如释放锁)。</p>
<p>等到设备处于充电状态或者电量充足的时候才进行耗时耗电操作(如分享传送数据、图片处理等)</p>
<p>触发网络请求的操作，每次都会保持无线信号持续一段时间，我们可以把零散的网络请求打包进行一次操作，避免过多的无线信号引起的电量消耗(例如APP的数据采集)。</p>
<p>Battery Historian Tool(Android 5.0)这个工具可以详细查看各类应用的用电情况。</p>
<h2 id="APK_瘦身">APK 瘦身</h2><h4 id="代码瘦身">代码瘦身</h4><p>库的使用可以极大方便开发者快速开发产品，但也引入了潜在的 bug 以及库过大导致APK过大的问题。移除没有用的 dependency libraries 是一个很好的建议。另外适当的给库瘦身(提取自己想要的功能)也很重要。如果对 APK 代码非常熟悉可以使用 Proguard （会遍历你的所有代码然后找出无用处的代码）优化。</p>
<h4 id="控制资源文件">控制资源文件</h4><p>剔除没有用的资源文件(使用 Lint 可轻松检测到)。</p>
<p>资源里的照片先进行压缩再使用。合适的时候可以用代码控制图片大小作为不同分辨率屏幕的资源。</p>
<p>为应用提供 hdpi, xhdpi 和 xxhdpi 这几个屏幕密度的支持。如果某些设备不是这几个屏幕密度的，不用担心，Android 系统会自动使用存在的资源为设备计算然后提供资源文件。</p>
<h2 id="总结">总结</h2><p>出现卡顿的根本原因：系统绘制 View 超过 16ms，出现掉帧才导致卡顿或不流畅。解决方法：</p>
<ul>
<li>Hierarchy Viewer，Profile GPU rendering，traceview</li>
<li>抽象布局标签，使用标签 include、viewstub、merge</li>
<li>多使用缓存</li>
<li>尽量避免过度绘制</li>
<li>自定义复杂 View，动态更新 View 内容</li>
<li>正确使用 wakelock，保持 App 用电量</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/08/hello-world/" class="article-date">
  	<time datetime="2015-09-08T13:00:12.000Z" itemprop="datePublished">2015-09-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/08/hello-world/">Hello World</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 science09
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>