<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://science09.github.io/blog</id>
    <title>彼岸_未来 Blog</title>
    <updated>2022-11-08T14:01:39.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://science09.github.io/blog"/>
    <subtitle>彼岸_未来 Blog</subtitle>
    <icon>https://science09.github.io/img/favicon.png</icon>
    <entry>
        <title type="html"><![CDATA[Kubernetes中的DNS]]></title>
        <id>k8s-coredns</id>
        <link href="https://science09.github.io/blog/k8s-coredns"/>
        <updated>2022-11-08T14:01:39.000Z</updated>
        <summary type="html"><![CDATA[本篇，是 CoreDNS 的前篇之一，后续会着重介绍 CoreDNS，但是步步深入讲 CoreDNS，讲一下 Kubernetes，以及kubedns 有一定的必要，所以，就有了 CoreDNS 系列，本篇主要尽可能详尽的说明 Kubernetes 的DNS解析原理，以及 Kubernetes 集群中 DNS 解析目前存在的弊端和优化方式。]]></summary>
        <content type="html"><![CDATA[<p>本篇，是 CoreDNS 的前篇之一，后续会着重介绍 CoreDNS，但是步步深入讲 CoreDNS，讲一下 Kubernetes，以及kubedns 有一定的必要，所以，就有了 CoreDNS 系列，本篇主要尽可能详尽的说明 Kubernetes 的DNS解析原理，以及 Kubernetes 集群中 DNS 解析目前存在的弊端和优化方式。</p><p>在 Kubernetes 中，服务发现有几种方式：</p><ul><li>基于环境变量的方式</li><li>基于内部域名的方式</li></ul><p>基本上，使用环境变量的方式很少，主要还是使用内部域名这种服务发现的方式。</p><p>其中，基于内部域名的方式，涉及到 Kubernetes 内部域名的解析，而 kubedns，是 Kubernetes 官方的 DNS 解析组件。从 1.11 版本开始，kubeadm 已经使用第三方的 CoreDNS 替换官方的 kubedns 作为 Kubernetes 集群的内部域名解析组件，我们的重点，是 CoreDNS，但是在开始 CoreDNS 之前，需要先了解下 kubedns，后续，会对这2个 DNS 组件做对比，分析它们的优劣势。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="kubernetes-中的域名是如何解析的">Kubernetes 中的域名是如何解析的<a class="hash-link" href="#kubernetes-中的域名是如何解析的" title="标题的直接链接">​</a></h3><p>在 Kubernetes 中，比如服务 a 访问服务 b，对于同一个 Namespace下，可以直接在 pod 中，通过 curl b 来访问。对于跨 Namespace 的情况，服务名后边对应 Namespace即可。比如 curl b.default。那么，使用者这里边会有几个问题：</p><ul><li>①：服务名是什么？</li><li>②：为什么同一个 Namespace 下，直接访问服务名即可？不同 Namespace 下，需要带上 Namespace 才行？</li><li>③：为什么内部的域名可以做解析，原理是什么？</li></ul><p>DNS 如何解析，依赖容器内 resolv 文件的配置</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cat /etc/resolv.conf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nameserver 10.233.0.3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">search default.svc.cluster.local svc.cluster.local cluster.local</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个文件中，配置的 DNS Server，一般就是 K8S 中，kubedns 的 Service 的 ClusterIP，这个IP是虚拟IP，无法ping，但可以访问。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[root@node4 user1]# kubectl get svc -n kube-system</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">NAME                   TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)         AGE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kube-dns               ClusterIP   10.233.0.3      &lt;none&gt;        53/UDP,53/TCP   270d</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kubernetes-dashboard   ClusterIP   10.233.22.223   &lt;none&gt;        443/TCP         124d</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>所以，所有域名的解析，其实都要经过 kubedns 的虚拟IP 10.233.0.3 进行解析，不论是 Kubernetes 内部域名还是外部的域名。</p><p>Kubernetes 中，域名的全称，必须是 service-name.namespace.svc.cluster.local 这种模式，服务名，就是Kubernetes中 Service 的名称，所以，当我们执行下面的命令时：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">curl b</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>必须得有一个 Service 名称为 b，这是前提。
在容器内，会根据 /etc/resolve.conf 进行解析流程。选择 nameserver 10.233.0.3 进行解析，然后，用字符串 “b”，依次带入 /etc/resolve.conf 中的 search 域，进行DNS查找，分别是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// search 内容类似如下（不同的pod，第一个域会有所不同）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">search default.svc.cluster.local svc.cluster.local cluster.local</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>b.default.svc.cluster.local -&gt; b.svc.cluster.local -&gt; b.cluster.local ，直到找到为止。
所以，我们执行 <code>curl b</code>，或者执行 <code>curl b.default</code>，都可以完成DNS请求，这2个不同的操作，会分别进行不同的DNS查找步骤：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// curl b，可以一次性找到（b +default.svc.cluster.local）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b.default.svc.cluster.local</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// curl b.default，第一次找不到（ b.default + default.svc.cluster.local）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b.default.default.svc.cluster.local</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 第二次查找（ b.default + svc.cluster.local），可以找到</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b.default.svc.cluster.local</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="so-questions">So Questions<a class="hash-link" href="#so-questions" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="curl-b要比-curl-bdefault-效率高">curl b，要比 curl b.default 效率高？<a class="hash-link" href="#curl-b要比-curl-bdefault-效率高" title="标题的直接链接">​</a></h3><p>答案是肯定的，因为 curl b.default，多经过了一次 DNS 查询。
当执行 curl b.default，也就使用了带有命名空间的内部域名时，容器的第一个 DNS 请求是</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// b.default + default.svc.cluster.local</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b.default.default.svc.cluster.local</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当请求不到 DNS 结果时，使用</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// b.default + svc.cluster.local</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b.default.svc.cluster.local</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>进行请求，此时才可以得到正确的DNS解析。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="访问外部域名走-search-域吗">访问外部域名走 search 域吗<a class="hash-link" href="#访问外部域名走-search-域吗" title="标题的直接链接">​</a></h3><p>这个答案，不能说肯定也不能说否定，看情况，可以说，大部分情况要走 search 域。</p><p>我们以请求 youku.com 为例，通过抓包的方式，看一看在某个容器中访问 youku.com，进行的DNS查找的过程，都产生了什么样的数据包。注意：我们要抓DNS容器的包，就得先进入到DNS容器的网络中（而不是发起DNS请求的那个容器）。</p><p>由于DNS容器往往不具备bash，所以无法通过 docker exec 的方式进入容器内抓包，我们采用其他的方式：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 1、找到容器ID，并打印它的NS ID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">docker inspect --format "{{.State.Pid}}"  16938de418ac</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2、进入此容器的网络Namespace</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nsenter -n -t  54438</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 3、抓DNS包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tcpdump -i eth0 udp dst port 53|grep youku.com</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在其他的容器中，进行 youku.com 域名查找</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">nslookup  youku.com 172.22.121.65</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>信息</div><div class="admonitionContent_S0QG"><p> 注意：nslookup命令的最后指定DNS服务容器的IP，是因为，如果不指定，且DNS服务的容器存在多个的话，那么DNS请求，可能会均分到所有DNS服务的容器上，我们如果只抓某单个DNS服务容器抓到的包，可能就不全了，指定IP后，DNS的请求，就必然只会打到单个的DNS容器。抓包的数据才完整。</p></div></div><p>可以看到类似如下结果：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">17:01:28.732260 IP 172.20.92.100.36326 &gt; nodexxxx.domain: 4394+ A? youku.com.default.svc.cluster.local. (50)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17:01:28.733158 IP 172.20.92.100.49846 &gt; nodexxxx.domain: 60286+ A? youku.com.svc.cluster.local. (45)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17:01:28.733888 IP 172.20.92.100.51933 &gt; nodexxxx.domain: 63077+ A? youku.com.cluster.local. (41)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17:01:28.734588 IP 172.20.92.100.33401 &gt; nodexxxx.domain: 27896+ A? youku.com. (27)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17:01:28.734758 IP nodexxxx.34138 &gt; 192.168.x.x.domain: 27896+ A? youku.com. (27)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">我们可以看到，在真正解析 youku.com 之前，经历了 youku.com.default.svc.cluster.local. -&gt; youku.com.svc.cluster.local. -&gt; youku.com.cluster.local. -&gt; youku.com.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这也就意味着有3次DNS请求，是浪费的无意义的请求。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="为何会出现dns请求浪费的情况">为何会出现DNS请求浪费的情况<a class="hash-link" href="#为何会出现dns请求浪费的情况" title="标题的直接链接">​</a></h2><p>这是因为，在 Kubernetes 中，其实 /etc/resolv.conf 这个文件，并不止包含 nameserver 和 search 域，还包含了非常重要的一项：ndots。我们之前没有提及这个项，也是希望再次能引起读者重视。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[root@xxxx-67f54c6dff-h4zxq /]# cat /etc/resolv.conf </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nameserver 10.233.0.3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">search cicd.svc.cluster.local svc.cluster.local cluster.local</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">options ndots:5</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ndots:5，表示：如果查询的域名包含的点“.”，不到5个，那么进行DNS查找，将使用非完全限定名称（或者叫绝对域名），如果你查询的域名包含点数大于等于5，那么DNS查询，默认会使用绝对域名进行查询。举例来说：</p><p>如果我们请求的域名是，a.b.c.d.e，这个域名中有4个点，那么容器中进行DNS请求时，会使用非绝对域名进行查找，使用非绝对域名，会按照 /etc/resolv.conf 中的 search 域，走一遍追加匹配：</p><blockquote><p>a.b.c.d.e.cicd.svc.cluster.local. -&gt;
a.b.c.d.e.svc.cluster.local. -&gt;
a.b.c.d.e.cluster.local.</p></blockquote><p>直到找到为止。如果走完了search域还找不到，则使用 a.b.c.d.e. ，作为绝对域名进行DNS查找。</p><p>我们通过抓包分析一个具体案例：</p><p>域名中点数少于5个的情况：</p><p>// 对域名 a.b.c.d.ccccc 进行DNS解析请求 </p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[root@xxxxx-67f54c6dff-h4zxq /]# nslookup  a.b.c.d.ccccc 172.22.121.65 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Server:         172.22.121.65</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Address:        172.22.121.65#53</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">** server can't find a.b.c.d.ccccc: NXDOMAIN</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 抓包数据如下：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18:08:11.013497 IP 172.20.92.100.33387 &gt; node011094.domain: 28844+ A? a.b.c.d.ccccc.cicd.svc.cluster.local. (54)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18:08:11.014337 IP 172.20.92.100.33952 &gt; node011094.domain: 57782+ A? a.b.c.d.ccccc.svc.cluster.local. (49)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18:08:11.015079 IP 172.20.92.100.45984 &gt; node011094.domain: 55144+ A? a.b.c.d.ccccc.cluster.local. (45)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18:08:11.015747 IP 172.20.92.100.54589 &gt; node011094.domain: 22860+ A? a.b.c.d.ccccc. (31)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18:08:11.015970 IP node011094.36383 &gt; 192.168.x.x.domain: 22860+ A? a.b.c.d.ccccc. (31)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 结论：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 点数少于5个，先走search域，最后将其视为绝对域名进行查询</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>域名中点数&gt;=5个的情况：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 对域名 a.b.c.d.e.ccccc 进行DNS解析请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[root@xxxxx-67f54c6dff-h4zxq /]# nslookup  a.b.c.d.e.ccccc 172.22.121.65 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Server:         172.22.121.65</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Address:        172.22.121.65#53</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">** server can't find a.b.c.d.e.ccccc: NXDOMAIN</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 抓包数据如下：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18:10:14.514595 IP 172.20.92.100.34423 &gt; node011094.domain: 61170+ A? a.b.c.d.e.ccccc. (33)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18:10:14.514856 IP node011094.58522 &gt; 192.168.x.x.domain: 61170+ A? a.b.c.d.e.ccccc. (33)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18:10:14.515880 IP 172.20.92.100.49328 &gt; node011094.domain: 267+ A? a.b.c.d.e.ccccc.cicd.svc.cluster.local. (56)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18:10:14.516678 IP 172.20.92.100.35651 &gt; node011094.domain: 54181+ A? a.b.c.d.e.ccccc.svc.cluster.local. (51)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18:10:14.517356 IP 172.20.92.100.33259 &gt; node011094.domain: 53022+ A? a.b.c.d.e.ccccc.cluster.local. (47)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 结论：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 点数&gt;=5个，直接视为绝对域名进行查找，只有当查询不到的时候，才继续走 search 域。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="如何优化-dns-请求浪费的情况">如何优化 DNS 请求浪费的情况<a class="hash-link" href="#如何优化-dns-请求浪费的情况" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="优化方式1使用全限定域名">优化方式1：使用全限定域名<a class="hash-link" href="#优化方式1使用全限定域名" title="标题的直接链接">​</a></h3><p>其实最直接，最有效的优化方式，就是使用 “fully qualified name”，简单来说，使用“完全限定域名”（也叫绝对域名），你访问的域名，必须要以 “.” 为后缀，这样就会避免走 search 域进行匹配，我们抓包再试一次：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 注意：youku.com 后边有一个点 .</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nslookup  youku.com. 172.22.121.65</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在DNS服务容器上抓到的包如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">16:57:07.628112 IP 172.20.92.100.36772 &gt; nodexxxx.domain: 46851+ [1au] A? youku.com. (38)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16:57:07.628339 IP nodexxxx.47350 &gt; 192.168.x.x.domain: 46851+ [1au] A? youku.com. (38)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>并没有多余的DNS请求。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="优化方式2具体应用配置特定的-ndots">优化方式2：具体应用配置特定的 ndots<a class="hash-link" href="#优化方式2具体应用配置特定的-ndots" title="标题的直接链接">​</a></h3><p>其实，往往我们还真不太好用这种绝对域名的方式，有谁请求youku.com的时候，还写成 youku.com. 呢？</p><p>在 Kubernetes 中，默认设置了 ndots 值为5，是因为，Kubernetes 认为，内部域名，最长为5，要保证内部域名的请求，优先走集群内部的DNS，而不是将内部域名的DNS解析请求，有打到外网的机会，Kubernetes 设置 ndots 为5是一个比较合理的行为。</p><p>如果你需要定制这个长度，最好是为自己的业务，单独配置 ndots 即可（Pod为例，其实配置deployment最好）。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">apiVersion: v1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kind: Pod</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">metadata:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  namespace: default</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  name: dns-example</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spec:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  containers:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - name: test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      image: nginx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dnsConfig:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    options:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      - name: ndots</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        value: "1"</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="kubernetes-dns-策略">Kubernetes DNS 策略<a class="hash-link" href="#kubernetes-dns-策略" title="标题的直接链接">​</a></h3><p>在Kubernetes 中，有4种 DNS 策略，从 Kubernetes 源码中看：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // DNSClusterFirstWithHostNet indicates that the pod should use cluster DNS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // first, if it is available, then fall back on the default</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // (as determined by kubelet) DNS settings.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DNSClusterFirstWithHostNet DNSPolicy = "ClusterFirstWithHostNet"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // DNSClusterFirst indicates that the pod should use cluster DNS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // first unless hostNetwork is true, if it is available, then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // fall back on the default (as determined by kubelet) DNS settings.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DNSClusterFirst DNSPolicy = "ClusterFirst"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // DNSDefault indicates that the pod should use the default (as</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // determined by kubelet) DNS settings.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DNSDefault DNSPolicy = "Default"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // DNSNone indicates that the pod should use empty DNS settings. DNS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // parameters such as nameservers and search paths should be defined via</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // DNSConfig.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DNSNone DNSPolicy = "None"</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这几种DNS策略，需要在Pod，或者Deployment、RC等资源中，设置 dnsPolicy 即可，以 Pod 为例：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">apiVersion: v1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kind: Pod</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">metadata:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   labels:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    name: cadvisor-nodexxxx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hostip: 192.168.x.x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  name: cadvisor-nodexxxx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  namespace: monitoring</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spec:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  containers:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  - args:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - --profiling</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - --housekeeping_interval=10s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - --storage_duration=1m0s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    image: google/cadvisor:latest</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    name: cadvisor-nodexxxx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ports:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - containerPort: 8080</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      name: http</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      protocol: TCP</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    resources: {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    securityContext:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      privileged: true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    terminationMessagePath: /dev/termination-log</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    terminationMessagePolicy: File</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dnsPolicy: ClusterFirst</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  nodeName: nodexxxx</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>具体来说：</p><p>None</p><blockquote><p>  表示空的DNS设置
这种方式一般用于想要自定义 DNS 配置的场景，而且，往往需要和 dnsConfig 配合一起使用达到自定义 DNS 的目的。</p></blockquote><p>Default</p><blockquote><p>有人说 Default 的方式，是使用宿主机的方式，这种说法并不准确。
这种方式，其实是，让 kubelet 来决定使用何种 DNS 策略。而 kubelet 默认的方式，就是使用宿主机的 /etc/resolv.conf（可能这就是有人说使用宿主机的DNS策略的方式吧），但是，kubelet 是可以灵活来配置使用什么文件来进行DNS策略的，我们完全可以使用 kubelet 的参数：–resolv-conf=/etc/resolv.conf 来决定你的DNS解析文件地址。</p></blockquote><p>ClusterFirst</p><blockquote><p>这种方式，表示 POD 内的 DNS 使用集群中配置的 DNS 服务，简单来说，就是使用 Kubernetes 中 kubedns 或 coredns 服务进行域名解析。如果解析不成功，才会使用宿主机的 DNS 配置进行解析。</p></blockquote><p>ClusterFirstWithHostNet</p><blockquote><p>在某些场景下，我们的 POD 是用 HOST 模式启动的（HOST模式，是共享宿主机网络的），一旦用 HOST 模式，表示这个 POD 中的所有容器，都要使用宿主机的 /etc/resolv.conf 配置进行DNS查询，但如果你想使用了 HOST 模式，还继续使用 Kubernetes 的DNS服务，那就将 dnsPolicy 设置为 ClusterFirstWithHostNet。</p></blockquote>]]></content>
        <author>
            <name>science09</name>
            <uri>https://github.com/science09</uri>
        </author>
        <category label="k8s" term="k8s"/>
        <category label="CoreDNS" term="CoreDNS"/>
    </entry>
</feed>